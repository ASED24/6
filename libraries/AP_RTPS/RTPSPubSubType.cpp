/*
 * Copyright (C) 2016 Intel Corporation. All rights reserved.
 *
 * Based on a file auto-generated by the fastcdrgen tool with the following
 * Copyright and license:
 * Copyright (C) 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <string>
#include <string.h>

#include <fastcdr/Cdr.h>
#include <fastcdr/FastBuffer.h>
#include <fastcdr/exceptions/BadParamException.h>

#include "RTPSPubSubType.h"

template <class State>
RTPSPubSubType<State>::RTPSPubSubType(const std::string& topic)
{
    setName(topic.c_str());
    m_typeSize = (uint32_t)State::getMaxCdrSerializedSize();
    m_isGetKeyDefined = State::isKeyDefined();
    m_keyBuffer = (unsigned char*)malloc(State::getKeyMaxCdrSerializedSize() > 16 ? State::getKeyMaxCdrSerializedSize() : 16);
}

template <class State>
RTPSPubSubType<State>::~RTPSPubSubType()
{
    free(m_keyBuffer);
}

template <class State>
bool RTPSPubSubType<State>::serialize(void* data, SerializedPayload_t* payload)
{
    try {
        State* p_type = (State*)data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->max_size);
        eprosima::fastcdr::Cdr ser(fastbuffer);
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        p_type->serialize(ser);
        payload->length = (uint32_t)ser.getSerializedDataLength();
    } catch (...) {
        return false;
    }
    return true;
}

template <class State>
bool RTPSPubSubType<State>::deserialize(SerializedPayload_t* payload, void* data)
{
    try {
        State* p_type = (State*)data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length);
        eprosima::fastcdr::Cdr deser(fastbuffer, payload->encapsulation == CDR_BE ? eprosima::fastcdr::Cdr::BIG_ENDIANNESS : eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS);
        p_type->deserialize(deser);
    } catch (...) {
        return false;
    }
    return true;
}

template <class State>
void* RTPSPubSubType<State>::createData()
{
    try {
        return (void*)new State();
    } catch (...) {
        return nullptr;
    }
}

template <class State>
void RTPSPubSubType<State>::deleteData(void* data)
{
    try {
        delete ((State*)data);
    } catch (...) {
    }
}

template <class State>
bool RTPSPubSubType<State>::getKey(void* data, InstanceHandle_t* handle)
{
    try {
        if (!m_isGetKeyDefined)
            return false;
        State* p_type = (State*)data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer, State::getKeyMaxCdrSerializedSize());
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);
        p_type->serializeKey(ser);
        if (State::getKeyMaxCdrSerializedSize() > 16) {
            m_md5.init();
            m_md5.update(m_keyBuffer, (unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();

            memcpy(handle->value, m_md5.digest, 16);
        } else {
            memcpy(handle->value, m_keyBuffer, 16);
        }
    } catch (...) {
        return false;
    }

    return true;
}
