/*
 * Copyright (C) 2016 Intel Corporation. All rights reserved.
 *
 * Based on a file auto-generated by the fastcdrgen tool with the following
 * Copyright and license:
 * Copyright (C) 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <fastrtps/attributes/ParticipantAttributes.h>
#include <fastrtps/attributes/PublisherAttributes.h>
#include <fastrtps/participant/Participant.h>
#include <fastrtps/publisher/Publisher.h>

#include <fastrtps/Domain.h>

#include <fastrtps/utils/eClock.h>

#include "RTPSPublisher.h"

using namespace eprosima::fastrtps;

template <class State>
RTPSIsolatedPublisher<State>::~RTPSIsolatedPublisher()
{
    Domain::removeParticipant(participant);
    delete type;
}

template <class State>
bool RTPSIsolatedPublisher<State>::init(const std::string& publisher_name,
    const std::string& topic)
{
    try {
        ParticipantAttributes part_param;
        part_param.rtps.builtin.domainId = 0;
        part_param.rtps.builtin.leaseDuration = c_TimeInfinite;
        part_param.rtps.setName(publisher_name.c_str());
        participant = Domain::createParticipant(part_param);
        if (!participant) {
            return false;
        }

        type = new RTPSPubSubType<State>(topic);
        Domain::registerType(participant, (TopicDataType*)type);

        PublisherAttributes pub_param;
        pub_param.topic.topicKind = NO_KEY;
        pub_param.topic.topicDataType = type->getName();
        pub_param.topic.topicName = topic.c_str();
        publisher = Domain::createPublisher(participant, pub_param,
            (PublisherListener*)&listener);
        if (!publisher) {
            return false;
        }
    } catch (...) {
        return false;
    }

    return true;
}

template <class State>
void RTPSIsolatedPublisher<State>::PubListener::onPublicationMatched(Publisher* pub, MatchingInfo& info)
{
    if (info.status == MATCHED_MATCHING) {
        n_matched++;
    } else {
        n_matched--;
    }
}

template <class State>
int RTPSIsolatedPublisher<State>::publish_state(State& st)
{
    try {
        if (listener.n_matched > 0) {
            publisher->write(&st);
        }
    } catch (...) {
        return -1;
    }

    return listener.n_matched;
}

#include "AHRS.h"

template class RTPSIsolatedPublisher<AHRS>;
